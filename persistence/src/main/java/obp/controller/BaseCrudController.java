package obp.controller;

import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.client.RestTemplate;

import obp.object.Dictionary;
import obp.object.OBPBaseClass;
import obp.repo.UpdateableRepository;
import obp.services.Neo4jExportService;

@CrossOrigin
@RequestMapping
public abstract class BaseCrudController<T> {
    
    private Map<String, String> env = System.getenv();
    
    private String DICTIONARY_BASE = env.getOrDefault("PERSISTENCE_DICTIONARY_BASE", "https://obp-05.esl.saic.com:8085");
    
    protected final UpdateableRepository<T, String> repo;
    @Autowired Neo4jExportService neo4jService;
    
    BaseCrudController(UpdateableRepository<T, String> repo) {
        this.repo = repo;
    }


    /**
     * finds an object based on unique id
     *
     * @param id
     *          id of object
     * @return object specified by id
     */
    @PreAuthorize("#oauth2.hasScope('ROLE_RO')")
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public T get(@PathVariable String id) {
        return repo.findOne(id);
    }

    /**
     * returns all  non-core attributes for an object based on unique id
     * Returns null if no corresponding object is found.
     *
     * @param id
     *          id of object
     * @return object specified by id
     * @throws InvocationTargetException 
     * @throws IllegalArgumentException 
     * @throws IllegalAccessException 
     */
    @PreAuthorize("#oauth2.hasScope('ROLE_RO')")
    @RequestMapping(value = "/{id}/getAttributes", method = RequestMethod.GET)
    public Map<String, Object> getAttributes(@PathVariable String id, HttpServletRequest request) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {

        // if the object isn't in the DB, return a null
        OBPBaseClass obj = (OBPBaseClass) repo.findOne(id);
        if (obj == null) {
            return null;
        }

        String jwt = extractJwt(request);

        // create "attribs" as the "other attributes" from the object found in the DB.  Add to them
        // the attributes whose names match the attributes of the object type being retrieved.
        // This is all the attributes, not just the non-core ones.
        Map<String, Object> attribs = obj.getOtherAttributes();
        PropertyDescriptor[] propertyDescriptors = BeanUtils.getPropertyDescriptors(obj.getClass());
        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {
            String propertyName = propertyDescriptor.getName();
            if (attribs.get(propertyName) == null) { // FIXME - a null pointer error is sometimes triggering here
                Object propertyValue = propertyDescriptor.getReadMethod().invoke(obj);
                attribs.put(propertyName, propertyValue);
            }
            
        }

        // "all-attributes" is names of the non-core attributes
        List<String> allAttribs = getAllowableAttributes(obj.getClass().getSimpleName(), jwt);

        Map<String, Object> result = new HashMap<String, Object>();

        // Put map entries into the return object for each non-core attribute its name and value.
        for (String attrib : allAttribs) {
            // populate the result with the current value if it exists
            result.put(attrib, (attribs != null ? attribs.get(attrib) : null));
        }

        return result;
    }

    /**
     * saves an object to store.  This acts as an "upsert": it first looks to see if the item is
     * already persisted; then updates if found and inserts if not found.
     * 
     * @param object
     *          object to save
     * @return object persisted, including any info generated by the database
     */
    @PreAuthorize("#oauth2.hasScope('ROLE_RWCD')")
    @RequestMapping(method = RequestMethod.POST)
    public T save(@RequestBody T object, HttpServletRequest request) {
        OBPBaseClass obpObject = (OBPBaseClass) object;

        obpObject.setLastUpdated(new Date());

        String jwt = extractJwt(request);
        Map<String, Object> otherAttrs = obpObject.getOtherAttributes();
        String className = object.getClass().getSimpleName();
        Map<String, Object> cleanAttributes = getCleanAttributes(otherAttrs, className, jwt);
        obpObject.setOtherAttributes(cleanAttributes);

        T mongoObj = repo.save(object);
        neo4jService.modifyNode((OBPBaseClass) mongoObj, neo4jService.createNodeBeanName, jwt);
        return mongoObj; 
    }

    /**
     * updates any fields of an object that are not null
     * 
     * @param object
     *          object to edit, with modified fields non null
     * @return true if object updated, false if not
     */
    @PreAuthorize("#oauth2.hasScope('ROLE_RWO')")
    @RequestMapping(method = RequestMethod.PUT)
    public boolean update(@RequestBody T object, HttpServletRequest request) {
        OBPBaseClass obpObject = (OBPBaseClass) object;
        obpObject.setLastUpdated(new Date());

        String jwt = extractJwt(request);
        Map<String, Object> cleanAttributes = getCleanAttributes(obpObject.getOtherAttributes(), object.getClass().getSimpleName(), jwt);
        obpObject.setOtherAttributes(cleanAttributes);

        boolean result = repo.update(object);
        if(result)
            neo4jService.modifyNode((OBPBaseClass) object, neo4jService.updateNodeBeanName, jwt);
        return result;
    }

    /**
     * deletes an object
     * 
     * @param id
     *          id of object to delete
     * @return returns the object deleted
     */
    @PreAuthorize("#oauth2.hasScope('ROLE_RWCD')")
    @RequestMapping(value = "/{id}", method = RequestMethod.DELETE)
    public T delete(@PathVariable String id, HttpServletRequest request) {
        T deleted = get(id);
        String jwt = extractJwt(request);
        neo4jService.modifyNode((OBPBaseClass) deleted, neo4jService.deleteNodeBeanName, jwt);
        repo.delete(id);
        return deleted;
    }

    protected String extractJwt(HttpServletRequest request) {
        String bearer = request.getHeader("Authorization");
        String jwt = "";

        if (bearer != null) {
            String[] split = bearer.split(" ");
            if (split.length >= 2) {
                jwt = split[1];
            }
        }

        return jwt;
    }

    /**
     * Filter out any fields that are not valid for this object
     *
     * @param attribs
     * @param classType
     * @param jwt
     * @return
     */
    private Map<String, Object> getCleanAttributes(Map<String, Object> attribs, String classType, String jwt) {
        Map<String, Object> cleanAttribs = new HashMap<String, Object>();

        ArrayList<String> allowableAttribs = getAllowableAttributes(classType, jwt);

        // ignore any fields that are not valid for this object
        if (attribs != null) {
            for (String attrib : attribs.keySet()) {
                if (allowableAttribs != null && allowableAttribs.contains(attrib)) {
                    cleanAttribs.put(attrib, attribs.get(attrib));
                }
            }
        }

        return cleanAttribs;
    }

    private ArrayList<String> getAllowableAttributes(String classType, String jwt) {
        String url = DICTIONARY_BASE + "/dictionary/find/" + classType + "?jwt=" + jwt;

        RestTemplate rt = new RestTemplate();

        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + jwt);

        HttpEntity<Dictionary[]> entity = new HttpEntity<>(headers);
        ResponseEntity<Dictionary[]> response = rt.exchange(url, HttpMethod.GET, entity, Dictionary[].class);

        Dictionary[] array = response.getBody();
        ArrayList<String> fields = new ArrayList<String>();
        if (array.length > 0) {
            for (Dictionary d : array) {
                if (!d.isCore() && d.getEnabled()) {
                    fields.add(d.getField());
                }
            }
        }
        return fields;
    }
}
